{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Agony Authors: James Bannon , Julia Nguyen , Matthew Boccalon , Jermiah Joseph Contact: bhklab.jermiahjoseph@gmail.com Description: Agony implementation Introduction The notion of graph agony was developed out of a desire to find hierarchies in directed networks [2] . Intuitively, a hierarchy -- in an organization or social network, for example -- involves assigning levels or ranks to people such that the ranks are ordered. For example, the CEO of a company should rank higher than an intern. Agony works by trying to find a hierarchy that best reflects that structure of a given directed network. At a very high level the algorithms in [2] , [3] , and [4] operate on the same way: Input: A directed graph $G=(V,E)$. Output: A rank function $r^*:V\\to \\mathbb{N}$, and a value $A(G)$ that is the agony of the graph $G$. The values of $r^*$ and $A(G)$ are found by solving the following minimization problem: $$\\underset{r:V\\to\\mathbb{N}}{\\min}\\sum_{(u,v)\\in E}\\max(0,r(u)-r(v)+1)$$ where $r^*$ is the function that minimizes the above sum and $A(G)$ is the value achieved. Immediate Next Steps The most immediate next steps involve implementing the ability to compute the weighted and unweighted versions of agony as described in [3] and [4] , respectively. We should do this at least in first in pure python. Below are some next steps along with tentative assignments to project members. TO DO: - Read over Tiers for Peers [4] and define the most general form of the agony problem. (James) - Re-write the linear program agony code such that it's more readable. (James) - Write the C++ code in python likely using the heapq module for the priority queue. R also has a priority queue implemented . (James, Jermiah, Matthew) - De-bug and benchmark the python implementation against its C++ counterpart. (Jermiah, Matthew) - Investigate the weighted agony algorithm defined in [4] . (James, Jermiah, Matthew). The author of [4] has made a C++ implementation available . The files are also in this repo in the agony_cpp folder. Project Ideas Software Paper If we can write a decent python and/or R package we can release it as its own software paper. It might be worth talking to Ben about this because it's not clear if re-writing publicly available code is a worthy paper. That said, making a library available publicly in pure python or R is maybe worth circulating/publishing as a matter of record. Pharmacogenomics Papers The way I see it, there are two ways that we can proceed with a PGx style paper. One way involves using the agony itself as a biomarker. The second involves using agony for rank aggregation. Agony As A Biomarker In the unweighted case, the agony is bounded above by $|E|$ and Set Up Prerequisites Pixi is required to run this project. If you haven't installed it yet, follow these instructions Installation Clone this repository to your local machine Navigate to the project directory Set up the environment using Pixi: pixi install Usage agony bindings are available in the agony module. I've setup two tasks to showcase this pixi run help pixi run cycle_dfs Documentation Click here to view the full documentation. References \ud83d\udcc4 Annotated List of Papers [1.] Inferring Genome-Wide Interaction Networks Using the Phi-Mixing Coefficient ^[This paper introduces a novel algorithm based on the \u03c6-mixing coefficient from probability theory to infer genome-wide interaction networks. The method allows for the construction of weighted and directed networks that can contain cycles, and it has been applied to study subtypes of lung cancer, including small cell (SCLC) and non-small cell (NSCLC), as well as normal lung tissue. There is a github repo with an implementation that is a combination of C and Matlab.] [2.] Finding Hierarchy in Directed Online Social Networks ^ The authors define a measure of hierarchy within directed online social networks and present an efficient algorithm to compute this measure. This work provides insights into the structural organization of social networks and how hierarchical relationships can be identified and quantified. oai_citation:0\u2021ACM Digital Library [3.] Faster Way to Agony: Discovering Hierarchies in Directed Graphs ^ This paper presents an improved algorithm for computing \"agony,\" a metric used to quantify the hierarchical structure in directed graphs. The proposed method reduces the computational complexity from O(nm\u00b2) to O(m\u00b2), making it more practical for analyzing large-scale networks. oai_citation:1\u2021arXiv [4.] Tiers for Peers: A Practical Algorithm for Discovering Hierarchy in Weighted Networks ^ Building upon the concept of agony, this study extends the approach to weighted networks and introduces constraints on the number of hierarchical levels. The authors connect the problem to the capacitated circulation problem and provide both exact and heuristic solutions, demonstrating efficiency in handling large datasets. [5.] Reconstructing Directed Gene Regulatory Network by Only Gene Expression Data ^ The paper proposes the Context-Based Dependency Network (CBDN) method to reconstruct directed gene regulatory networks using solely gene expression data. This approach addresses the challenge of inferring regulatory directions without additional data, such as eQTLs or gene knock-out experiments, which are often unavailable for human tissue samples. [6.] Resolution of Ranking Hierarchies in Directed Networks ^[ranked stochastic block models] [7.] SCENIC: single-cell regulatory network inference and clustering ^[A paper that infers single cell gene regulatory networks. ] [8.] Inferring Regulatory Networks from Expression Data Using Tree-Based Methods ^[The GENIE3 algorithm for inferring directed gene regulatory networks. There exists a github repo with implementations in C, R, Matlab, and python. This is used in the SCENIC pipeline.] [9.] bLARS: An Algorithm to Infer Gene Regulatory Networks ^[Another algorithm for inferring directed gene regulatory networks from gene expression.] [10.] [Integrate Any Omics: Towards genome-wide data integration for patient stratification](https://arxiv.org/pdf/2401.07937) ^[] [11.] [Screening cell\u2013cell communication in spatial transcriptomics via collective optimal transport](https://www.nature.com/articles/s41592-022-01728-4)","title":"Home"},{"location":"#agony","text":"Authors: James Bannon , Julia Nguyen , Matthew Boccalon , Jermiah Joseph Contact: bhklab.jermiahjoseph@gmail.com Description: Agony implementation","title":"Agony"},{"location":"#introduction","text":"The notion of graph agony was developed out of a desire to find hierarchies in directed networks [2] . Intuitively, a hierarchy -- in an organization or social network, for example -- involves assigning levels or ranks to people such that the ranks are ordered. For example, the CEO of a company should rank higher than an intern. Agony works by trying to find a hierarchy that best reflects that structure of a given directed network. At a very high level the algorithms in [2] , [3] , and [4] operate on the same way: Input: A directed graph $G=(V,E)$. Output: A rank function $r^*:V\\to \\mathbb{N}$, and a value $A(G)$ that is the agony of the graph $G$. The values of $r^*$ and $A(G)$ are found by solving the following minimization problem: $$\\underset{r:V\\to\\mathbb{N}}{\\min}\\sum_{(u,v)\\in E}\\max(0,r(u)-r(v)+1)$$ where $r^*$ is the function that minimizes the above sum and $A(G)$ is the value achieved.","title":"Introduction"},{"location":"#immediate-next-steps","text":"The most immediate next steps involve implementing the ability to compute the weighted and unweighted versions of agony as described in [3] and [4] , respectively. We should do this at least in first in pure python. Below are some next steps along with tentative assignments to project members. TO DO: - Read over Tiers for Peers [4] and define the most general form of the agony problem. (James) - Re-write the linear program agony code such that it's more readable. (James) - Write the C++ code in python likely using the heapq module for the priority queue. R also has a priority queue implemented . (James, Jermiah, Matthew) - De-bug and benchmark the python implementation against its C++ counterpart. (Jermiah, Matthew) - Investigate the weighted agony algorithm defined in [4] . (James, Jermiah, Matthew). The author of [4] has made a C++ implementation available . The files are also in this repo in the agony_cpp folder.","title":"Immediate Next Steps"},{"location":"#project-ideas","text":"","title":"Project Ideas"},{"location":"#software-paper","text":"If we can write a decent python and/or R package we can release it as its own software paper. It might be worth talking to Ben about this because it's not clear if re-writing publicly available code is a worthy paper. That said, making a library available publicly in pure python or R is maybe worth circulating/publishing as a matter of record.","title":"Software Paper"},{"location":"#pharmacogenomics-papers","text":"The way I see it, there are two ways that we can proceed with a PGx style paper. One way involves using the agony itself as a biomarker. The second involves using agony for rank aggregation.","title":"Pharmacogenomics Papers"},{"location":"#agony-as-a-biomarker","text":"In the unweighted case, the agony is bounded above by $|E|$ and","title":"Agony As A Biomarker"},{"location":"#set-up","text":"","title":"Set Up"},{"location":"#prerequisites","text":"Pixi is required to run this project. If you haven't installed it yet, follow these instructions","title":"Prerequisites"},{"location":"#installation","text":"Clone this repository to your local machine Navigate to the project directory Set up the environment using Pixi: pixi install","title":"Installation"},{"location":"#usage","text":"agony bindings are available in the agony module. I've setup two tasks to showcase this pixi run help pixi run cycle_dfs","title":"Usage"},{"location":"#documentation","text":"Click here to view the full documentation.","title":"Documentation"},{"location":"#references","text":"","title":"References"},{"location":"#annotated-list-of-papers","text":"","title":"\ud83d\udcc4 Annotated List of Papers"},{"location":"#1-inferring-genome-wide-interaction-networks-using-the-phi-mixing-coefficient","text":"^[This paper introduces a novel algorithm based on the \u03c6-mixing coefficient from probability theory to infer genome-wide interaction networks. The method allows for the construction of weighted and directed networks that can contain cycles, and it has been applied to study subtypes of lung cancer, including small cell (SCLC) and non-small cell (NSCLC), as well as normal lung tissue. There is a github repo with an implementation that is a combination of C and Matlab.]","title":"[1.] Inferring Genome-Wide Interaction Networks Using the Phi-Mixing Coefficient"},{"location":"#2-finding-hierarchy-in-directed-online-social-networks","text":"^ The authors define a measure of hierarchy within directed online social networks and present an efficient algorithm to compute this measure. This work provides insights into the structural organization of social networks and how hierarchical relationships can be identified and quantified. oai_citation:0\u2021ACM Digital Library","title":"[2.] Finding Hierarchy in Directed Online Social Networks"},{"location":"#3-faster-way-to-agony-discovering-hierarchies-in-directed-graphs","text":"^ This paper presents an improved algorithm for computing \"agony,\" a metric used to quantify the hierarchical structure in directed graphs. The proposed method reduces the computational complexity from O(nm\u00b2) to O(m\u00b2), making it more practical for analyzing large-scale networks. oai_citation:1\u2021arXiv","title":"[3.] Faster Way to Agony: Discovering Hierarchies in Directed Graphs"},{"location":"#4-tiers-for-peers-a-practical-algorithm-for-discovering-hierarchy-in-weighted-networks","text":"^ Building upon the concept of agony, this study extends the approach to weighted networks and introduces constraints on the number of hierarchical levels. The authors connect the problem to the capacitated circulation problem and provide both exact and heuristic solutions, demonstrating efficiency in handling large datasets.","title":"[4.] Tiers for Peers: A Practical Algorithm for Discovering Hierarchy in Weighted Networks"},{"location":"#5-reconstructing-directed-gene-regulatory-network-by-only-gene-expression-data","text":"^ The paper proposes the Context-Based Dependency Network (CBDN) method to reconstruct directed gene regulatory networks using solely gene expression data. This approach addresses the challenge of inferring regulatory directions without additional data, such as eQTLs or gene knock-out experiments, which are often unavailable for human tissue samples.","title":"[5.] Reconstructing Directed Gene Regulatory Network by Only Gene Expression Data"},{"location":"#6-resolution-of-ranking-hierarchies-in-directed-networks","text":"^[ranked stochastic block models]","title":"[6.] Resolution of Ranking Hierarchies in Directed Networks"},{"location":"#7-scenic-single-cell-regulatory-network-inference-and-clustering","text":"^[A paper that infers single cell gene regulatory networks. ]","title":"[7.] SCENIC: single-cell regulatory network inference and clustering"},{"location":"#8-inferring-regulatory-networks-from-expression-data-using-tree-based-methods","text":"^[The GENIE3 algorithm for inferring directed gene regulatory networks. There exists a github repo with implementations in C, R, Matlab, and python. This is used in the SCENIC pipeline.]","title":"[8.] Inferring Regulatory Networks from Expression Data Using Tree-Based Methods"},{"location":"#9-blars-an-algorithm-to-infer-gene-regulatory-networks","text":"^[Another algorithm for inferring directed gene regulatory networks from gene expression.]","title":"[9.] bLARS: An Algorithm to Infer Gene Regulatory Networks"},{"location":"#10-integrate-any-omics-towards-genome-wide","text":"data integration for patient stratification](https://arxiv.org/pdf/2401.07937) ^[]","title":"[10.] [Integrate Any Omics: Towards genome-wide"},{"location":"#11-screening-cellcell-communication-in","text":"spatial transcriptomics via collective optimal transport](https://www.nature.com/articles/s41592-022-01728-4)","title":"[11.] [Screening cell\u2013cell communication in"},{"location":"cpp_for_python_devs/","text":"Agony Project Documentation This document provides an overview of the Agony project, aimed at helping Python developers understand the C++ codebase and its components. Project Structure The Agony project contains both C++ and Python code, with the core algorithms implemented in C++ and Python bindings that make these algorithms accessible from Python. cpp/agony/ - Core C++ implementation \u251c\u2500\u2500 include/ - Header files that define interfaces \u251c\u2500\u2500 src/ - Implementation files \u251c\u2500\u2500 bindings/ - Python binding code \u2514\u2500\u2500 old/ - Legacy implementations (for reference) src/ - Python package code docs/ - Documentation Core Components DirectedGraph Class The DirectedGraph class is the primary data structure used in the project. It implements a directed graph with weighted edges, similar to NetworkX's DiGraph in Python. What is a Directed Graph? A directed graph (or digraph) is a set of vertices (nodes) connected by edges, where the edges have a direction from one vertex to another. In our implementation: Nodes are represented by integer IDs Edges connect a source node to a target node Edges can have weights (default is 1.0) C++ Types and Their Python Equivalents C++ Type Python Equivalent Description std::unordered_set<int> set() A collection of unique node IDs std::unordered_map<K,V> dict() A key-value mapping, like Python dictionaries std::vector<T> list() A sequence container, similar to Python lists std::pair<T1,T2> tuple() A pair of values, like a 2-element Python tuple const T& N/A A reference to data (avoids copying, improves performance) \"Odd\" Type Descriptions Some C++ types might look confusing to Python developers: Template parameters (things in <> brackets): These are like Python's type hints, but required by the compiler. For example, std::vector<int> is a list that can only contain integers. const keyword : Indicates that something won't be modified. When you see const in function parameters or return types, it's saying \"this won't change the data.\" & symbol : Indicates a reference. Instead of copying data, C++ can pass a reference to the original data for efficiency. Function names with :: operator : The :: operator in C++ shows namespace or class membership, similar to Python's dot notation. Basic Usage While Python developers won't directly use the C++ code, understanding the underlying implementation helps when using the Python bindings. The graph implementation allows: Adding nodes to the graph Adding weighted directed edges between nodes Checking if edges exist Getting weights of edges Retrieving all nodes in the graph Finding all neighbors of a node Advanced C++ Concepts for Python Developers Namespaces C++ uses namespaces (like namespace agony ) to prevent naming collisions. This is similar to Python modules and helps organize code. Custom Hash Functions In C++, unlike Python, you need to define hash functions for custom types when using them as keys in hash tables. The pair_hash struct serves this purpose for pairs of integers. Function Modifiers const after a function declaration means the function won't modify the object. Function declarations without definitions are the C++ equivalent of abstract methods. Memory Management C++ requires more explicit memory management than Python. Our implementation uses: References (with & ) to avoid unnecessary copying Container classes that handle memory allocation/deallocation Building and Extending If you need to modify the C++ code, you'll need to: Update the appropriate files in cpp/agony/include and cpp/agony/src Rebuild the project (follow build instructions in README) Ensure Python bindings are updated if interfaces change Python developers should focus on the Python interface rather than modifying the C++ code directly unless absolutely necessary.","title":"Agony Project Documentation"},{"location":"cpp_for_python_devs/#agony-project-documentation","text":"This document provides an overview of the Agony project, aimed at helping Python developers understand the C++ codebase and its components.","title":"Agony Project Documentation"},{"location":"cpp_for_python_devs/#project-structure","text":"The Agony project contains both C++ and Python code, with the core algorithms implemented in C++ and Python bindings that make these algorithms accessible from Python. cpp/agony/ - Core C++ implementation \u251c\u2500\u2500 include/ - Header files that define interfaces \u251c\u2500\u2500 src/ - Implementation files \u251c\u2500\u2500 bindings/ - Python binding code \u2514\u2500\u2500 old/ - Legacy implementations (for reference) src/ - Python package code docs/ - Documentation","title":"Project Structure"},{"location":"cpp_for_python_devs/#core-components","text":"","title":"Core Components"},{"location":"cpp_for_python_devs/#directedgraph-class","text":"The DirectedGraph class is the primary data structure used in the project. It implements a directed graph with weighted edges, similar to NetworkX's DiGraph in Python.","title":"DirectedGraph Class"},{"location":"cpp_for_python_devs/#what-is-a-directed-graph","text":"A directed graph (or digraph) is a set of vertices (nodes) connected by edges, where the edges have a direction from one vertex to another. In our implementation: Nodes are represented by integer IDs Edges connect a source node to a target node Edges can have weights (default is 1.0)","title":"What is a Directed Graph?"},{"location":"cpp_for_python_devs/#c-types-and-their-python-equivalents","text":"C++ Type Python Equivalent Description std::unordered_set<int> set() A collection of unique node IDs std::unordered_map<K,V> dict() A key-value mapping, like Python dictionaries std::vector<T> list() A sequence container, similar to Python lists std::pair<T1,T2> tuple() A pair of values, like a 2-element Python tuple const T& N/A A reference to data (avoids copying, improves performance)","title":"C++ Types and Their Python Equivalents"},{"location":"cpp_for_python_devs/#odd-type-descriptions","text":"Some C++ types might look confusing to Python developers: Template parameters (things in <> brackets): These are like Python's type hints, but required by the compiler. For example, std::vector<int> is a list that can only contain integers. const keyword : Indicates that something won't be modified. When you see const in function parameters or return types, it's saying \"this won't change the data.\" & symbol : Indicates a reference. Instead of copying data, C++ can pass a reference to the original data for efficiency. Function names with :: operator : The :: operator in C++ shows namespace or class membership, similar to Python's dot notation.","title":"\"Odd\" Type Descriptions"},{"location":"cpp_for_python_devs/#basic-usage","text":"While Python developers won't directly use the C++ code, understanding the underlying implementation helps when using the Python bindings. The graph implementation allows: Adding nodes to the graph Adding weighted directed edges between nodes Checking if edges exist Getting weights of edges Retrieving all nodes in the graph Finding all neighbors of a node","title":"Basic Usage"},{"location":"cpp_for_python_devs/#advanced-c-concepts-for-python-developers","text":"","title":"Advanced C++ Concepts for Python Developers"},{"location":"cpp_for_python_devs/#namespaces","text":"C++ uses namespaces (like namespace agony ) to prevent naming collisions. This is similar to Python modules and helps organize code.","title":"Namespaces"},{"location":"cpp_for_python_devs/#custom-hash-functions","text":"In C++, unlike Python, you need to define hash functions for custom types when using them as keys in hash tables. The pair_hash struct serves this purpose for pairs of integers.","title":"Custom Hash Functions"},{"location":"cpp_for_python_devs/#function-modifiers","text":"const after a function declaration means the function won't modify the object. Function declarations without definitions are the C++ equivalent of abstract methods.","title":"Function Modifiers"},{"location":"cpp_for_python_devs/#memory-management","text":"C++ requires more explicit memory management than Python. Our implementation uses: References (with & ) to avoid unnecessary copying Container classes that handle memory allocation/deallocation","title":"Memory Management"},{"location":"cpp_for_python_devs/#building-and-extending","text":"If you need to modify the C++ code, you'll need to: Update the appropriate files in cpp/agony/include and cpp/agony/src Rebuild the project (follow build instructions in README) Ensure Python bindings are updated if interfaces change Python developers should focus on the Python interface rather than modifying the C++ code directly unless absolutely necessary.","title":"Building and Extending"},{"location":"data_sources/","text":"Data Sources Overview This section should document all data sources used in your project. Proper documentation ensures reproducibility and helps others understand your research methodology. How to Document Your Data For each data source, include the following information: 1. External Data Sources Name : Official name of the dataset Version/Date : Version number or access date URL : Link to the data source Access Method : How the data was obtained (direct download, API, etc.) Access Date : When the data was accessed/retrieved Data Format : Format of the data (FASTQ, DICOM, CSV, etc.) Citation : Proper academic citation if applicable License : Usage restrictions and attribution requirements Example: ## TCGA RNA-Seq Data - **Name**: The Cancer Genome Atlas RNA-Seq Data - **Version**: Data release 28.0 - March 2021 - **URL**: https://portal.gdc.cancer.gov/ - **Access Method**: GDC Data Transfer Tool - **Access Date**: 2021-03-15 - **Citation**: The Cancer Genome Atlas Network. (2012). Comprehensive molecular portraits of human breast tumours. Nature, 490(7418), 61-70. - **License**: [NIH Genomic Data Sharing Policy](https://sharing.nih.gov/genomic-data-sharing-policy) 2. Internal/Generated Data Name : Descriptive name of the dataset Creation Date : When the data was generated Creation Method : Brief description of how the data was created Input Data : What source data was used Processing Scripts : References to scripts/Github Repo used to generate this data Example: ## Processed RNA-Seq Data - **Name**: Processed RNA-Seq Data for TCGA-BRCA - **Creation Date**: 2021-04-01 - **Creation Method**: Processed using kallisto and DESeq2 - **Input Data**: FASTQ Data obtained from the SRA database - **Processing Scripts**: [GitHub Repo](https://github.com/tcga-brca-rnaseq) 3. Data Dictionary For complex datasets, include a data dictionary that explains: Column Name Data Type Description Units Possible Values patient_id string Unique patient identifier N/A TCGA-XX-XXXX format age integer Patient age at diagnosis years 18-100 expression float Gene expression value TPM Any positive value Best Practices Store raw data in data/rawdata/ and never modify it Store processed data in data/procdata/ and all code used to generate it should be in workflow/scripts/ Document all processing steps Track data provenance (where data came from and how it was modified) Respect data usage agreements and licenses! This is especially important for data that should not be shared publicly","title":"Data Sources"},{"location":"data_sources/#data-sources","text":"","title":"Data Sources"},{"location":"data_sources/#overview","text":"This section should document all data sources used in your project. Proper documentation ensures reproducibility and helps others understand your research methodology.","title":"Overview"},{"location":"data_sources/#how-to-document-your-data","text":"For each data source, include the following information:","title":"How to Document Your Data"},{"location":"data_sources/#1-external-data-sources","text":"Name : Official name of the dataset Version/Date : Version number or access date URL : Link to the data source Access Method : How the data was obtained (direct download, API, etc.) Access Date : When the data was accessed/retrieved Data Format : Format of the data (FASTQ, DICOM, CSV, etc.) Citation : Proper academic citation if applicable License : Usage restrictions and attribution requirements Example: ## TCGA RNA-Seq Data - **Name**: The Cancer Genome Atlas RNA-Seq Data - **Version**: Data release 28.0 - March 2021 - **URL**: https://portal.gdc.cancer.gov/ - **Access Method**: GDC Data Transfer Tool - **Access Date**: 2021-03-15 - **Citation**: The Cancer Genome Atlas Network. (2012). Comprehensive molecular portraits of human breast tumours. Nature, 490(7418), 61-70. - **License**: [NIH Genomic Data Sharing Policy](https://sharing.nih.gov/genomic-data-sharing-policy)","title":"1. External Data Sources"},{"location":"data_sources/#2-internalgenerated-data","text":"Name : Descriptive name of the dataset Creation Date : When the data was generated Creation Method : Brief description of how the data was created Input Data : What source data was used Processing Scripts : References to scripts/Github Repo used to generate this data Example: ## Processed RNA-Seq Data - **Name**: Processed RNA-Seq Data for TCGA-BRCA - **Creation Date**: 2021-04-01 - **Creation Method**: Processed using kallisto and DESeq2 - **Input Data**: FASTQ Data obtained from the SRA database - **Processing Scripts**: [GitHub Repo](https://github.com/tcga-brca-rnaseq)","title":"2. Internal/Generated Data"},{"location":"data_sources/#3-data-dictionary","text":"For complex datasets, include a data dictionary that explains: Column Name Data Type Description Units Possible Values patient_id string Unique patient identifier N/A TCGA-XX-XXXX format age integer Patient age at diagnosis years 18-100 expression float Gene expression value TPM Any positive value","title":"3. Data Dictionary"},{"location":"data_sources/#best-practices","text":"Store raw data in data/rawdata/ and never modify it Store processed data in data/procdata/ and all code used to generate it should be in workflow/scripts/ Document all processing steps Track data provenance (where data came from and how it was modified) Respect data usage agreements and licenses! This is especially important for data that should not be shared publicly","title":"Best Practices"},{"location":"devnotes/","text":"Developer Notes Purpose of This Section This section is for documenting technical decisions, challenges, and solutions encountered during your project. These notes are valuable for: Future you (who will forget why certain decisions were made) Collaborators who join the project later People coming from your publication who want to reproduce your work Anyone who might want to extend your research What to Document Design Decisions Document important decisions about your project's architecture, algorithms, or methodologies: ## Choice of RNA-Seq Analysis Pipeline [2025-04-25] We chose the kallisto over STAR pipeline for the following reasons: 1. The CCLE dataset is very large, and kallisto is faster for quantifying large datasets 2. GDSC used kallisto, so we can compare our results with theirs Technical Challenges Record significant problems you encountered and how you solved them ## Sample Name Format Issue [2025-04-25] We encountered a problem with sample name formats between the CCLE and GDSC datasets. The CCLE dataset uses \"BRCA-XX-XXXX\" format, while the GDSC dataset uses \"BRCA-XX-XXXX-XX\". We had to write a script to remove the last two characters from the sample names in the GDSC dataset. Dependencies and Environment Document specific version requirements or compatibility issues: ## Critical Version Dependencies [2025-04-25] SimpleITK 2.4.1 introduced a bug that flips images, so we froze version 2.4.0 Best Practices Date your entries when appropriate Link to relevant code files or external resources Include small code snippets when helpful Note alternatives you considered and why they were rejected Document failed approaches to prevent others from repeating mistakes Update notes when major changes are made to the approach","title":"Developer Notes"},{"location":"devnotes/#developer-notes","text":"","title":"Developer Notes"},{"location":"devnotes/#purpose-of-this-section","text":"This section is for documenting technical decisions, challenges, and solutions encountered during your project. These notes are valuable for: Future you (who will forget why certain decisions were made) Collaborators who join the project later People coming from your publication who want to reproduce your work Anyone who might want to extend your research","title":"Purpose of This Section"},{"location":"devnotes/#what-to-document","text":"","title":"What to Document"},{"location":"devnotes/#design-decisions","text":"Document important decisions about your project's architecture, algorithms, or methodologies: ## Choice of RNA-Seq Analysis Pipeline [2025-04-25] We chose the kallisto over STAR pipeline for the following reasons: 1. The CCLE dataset is very large, and kallisto is faster for quantifying large datasets 2. GDSC used kallisto, so we can compare our results with theirs","title":"Design Decisions"},{"location":"devnotes/#technical-challenges","text":"Record significant problems you encountered and how you solved them ## Sample Name Format Issue [2025-04-25] We encountered a problem with sample name formats between the CCLE and GDSC datasets. The CCLE dataset uses \"BRCA-XX-XXXX\" format, while the GDSC dataset uses \"BRCA-XX-XXXX-XX\". We had to write a script to remove the last two characters from the sample names in the GDSC dataset.","title":"Technical Challenges"},{"location":"devnotes/#dependencies-and-environment","text":"Document specific version requirements or compatibility issues: ## Critical Version Dependencies [2025-04-25] SimpleITK 2.4.1 introduced a bug that flips images, so we froze version 2.4.0","title":"Dependencies and Environment"},{"location":"devnotes/#best-practices","text":"Date your entries when appropriate Link to relevant code files or external resources Include small code snippets when helpful Note alternatives you considered and why they were rejected Document failed approaches to prevent others from repeating mistakes Update notes when major changes are made to the approach","title":"Best Practices"},{"location":"python_bindings/","text":"Python Bindings in Agony This document explains how the C++ code in Agony is made accessible to Python users through bindings. What are Python Bindings? Python bindings are code that allows Python to interact with libraries written in other languages, such as C++. They serve as a bridge between Python and C++, enabling Python code to call C++ functions and work with C++ objects. In the Agony project, we use bindings to make our efficient C++ graph algorithms available to Python users, combining C++'s performance with Python's ease of use. How Bindings Work When you use a binding-enabled library in Python, you're actually: Importing a Python module that contains special code to interface with C++ Using Python objects that represent the underlying C++ objects Calling methods that forward your requests to the C++ implementations Getting results back that have been converted from C++ types to Python types Type Conversions The bindings automatically handle conversions between C++ and Python types: C++ Type Python Type int , double int , float std::string str std::vector<T> list std::unordered_map<K,V> dict std::unordered_set<T> set Custom C++ classes Custom Python classes Using the Python API From Python, you would use the bound library like this: # Import the module exposed by the bindings import agony # Create a directed graph graph = agony.DirectedGraph() # Add nodes graph.add_node(1) graph.add_node(2) graph.add_node(3) # Add edges graph.add_edge(1, 2, 0.5) # Edge from node 1 to 2 with weight 0.5 graph.add_edge(2, 3) # Edge from node 2 to 3 with default weight 1.0 # Check if an edge exists if graph.has_edge(1, 2): print(f\"Edge weight: {graph.get_edge_weight(1, 2)}\") # Should print 0.5 # Get all nodes all_nodes = graph.nodes() # Returns a Python set: {1, 2, 3} # Get neighbors of a node neighbors_of_2 = graph.neighbors(2) # Returns a list of (neighbor, weight) tuples","title":"Python Bindings in Agony"},{"location":"python_bindings/#python-bindings-in-agony","text":"This document explains how the C++ code in Agony is made accessible to Python users through bindings.","title":"Python Bindings in Agony"},{"location":"python_bindings/#what-are-python-bindings","text":"Python bindings are code that allows Python to interact with libraries written in other languages, such as C++. They serve as a bridge between Python and C++, enabling Python code to call C++ functions and work with C++ objects. In the Agony project, we use bindings to make our efficient C++ graph algorithms available to Python users, combining C++'s performance with Python's ease of use.","title":"What are Python Bindings?"},{"location":"python_bindings/#how-bindings-work","text":"When you use a binding-enabled library in Python, you're actually: Importing a Python module that contains special code to interface with C++ Using Python objects that represent the underlying C++ objects Calling methods that forward your requests to the C++ implementations Getting results back that have been converted from C++ types to Python types","title":"How Bindings Work"},{"location":"python_bindings/#type-conversions","text":"The bindings automatically handle conversions between C++ and Python types: C++ Type Python Type int , double int , float std::string str std::vector<T> list std::unordered_map<K,V> dict std::unordered_set<T> set Custom C++ classes Custom Python classes","title":"Type Conversions"},{"location":"python_bindings/#using-the-python-api","text":"From Python, you would use the bound library like this: # Import the module exposed by the bindings import agony # Create a directed graph graph = agony.DirectedGraph() # Add nodes graph.add_node(1) graph.add_node(2) graph.add_node(3) # Add edges graph.add_edge(1, 2, 0.5) # Edge from node 1 to 2 with weight 0.5 graph.add_edge(2, 3) # Edge from node 2 to 3 with default weight 1.0 # Check if an edge exists if graph.has_edge(1, 2): print(f\"Edge weight: {graph.get_edge_weight(1, 2)}\") # Should print 0.5 # Get all nodes all_nodes = graph.nodes() # Returns a Python set: {1, 2, 3} # Get neighbors of a node neighbors_of_2 = graph.neighbors(2) # Returns a list of (neighbor, weight) tuples","title":"Using the Python API"},{"location":"usage/","text":"Usage Guide Project Configuration TODO:: discuss how to edit the configuration files in the config/ directory to match your research parameters TODO:: discuss how to add your input data to the data/rawdata/ directory and document it properly in the docs/data_sources/ directory TODO:: discuss how to manage and organize your data sources effectively Running Your Analysis TODO:: discuss using pixi tasks to run the analysis","title":"Usage"},{"location":"usage/#usage-guide","text":"","title":"Usage Guide"},{"location":"usage/#project-configuration","text":"TODO:: discuss how to edit the configuration files in the config/ directory to match your research parameters TODO:: discuss how to add your input data to the data/rawdata/ directory and document it properly in the docs/data_sources/ directory TODO:: discuss how to manage and organize your data sources effectively","title":"Project Configuration"},{"location":"usage/#running-your-analysis","text":"TODO:: discuss using pixi tasks to run the analysis","title":"Running Your Analysis"}]}